-- set serveroutput on;
-- alter session set "_ORACLE_SCRIPT"=true;

-- EJERCICIO 6:
-- DESARROLLA UNA FUNCION QUE DEVUELVA EL NUMERO DE AÑOS COMPLETOS QUE HAY ENTRE DOS FECHAS QUE SE PASAN COMO PARAMETROS

CREATE OR REPLACE FUNCTION FullYearsBetweenDates (DATE1 DATE, DATE2 DATE) RETURN NUMBER
IS
    YEAR1 NUMBER;
    YEAR2 NUMBER;
    YEARSBETWEEN NUMBER;
BEGIN
    YEAR1 := EXTRACT(YEAR FROM DATE1);
    YEAR2 := EXTRACT(YEAR FROM DATE2);
    YEARSBETWEEN := ABS(YEAR1 - YEAR2);
    IF MONTHS_BETWEEN(DATE1, DATE2) < 12 THEN
        YEARSBETWEEN := YEARSBETWEEN - 1;
    END IF;

    RETURN ABS(YEARSBETWEEN);
END;
/

-- EJERCICIO 7:
    -- ESCRIBE UNA FUNCIÓN QUE, HACIENDO USO DE LA FUNCIÓN ANTERIOR, DEVUELVA LOS TRIENIOS QUE HAY ENTRE DOS FECHAS (UN TRIENIO SON TRES AÑOS)
CREATE OR REPLACE FUNCTION TRIENNIUMSBETWEENDATES (DATE1 DATE, DATE2 DATE) RETURN NUMBER
IS
    YEARSBETWEENDATES NUMBER;
    TRIENIUMS NUMBER;
BEGIN
    SELECT FULLYEARSBETWEENDATES (DATE1, DATE2) INTO YEARSBETWEENDATES FROM DUAL;
    TRIENIUMS := ROUND((YEARSBETWEENDATES / 3),0);
    RETURN TRIENIUMS;
END;
/

--EJERCICIO 8:
    -- CODIFICA UN PROCEDIMIENTO QUE RECIBA UNA LISTA DE HASTA CINCO NÚMEROS Y VISUALICE SU SUMA
CREATE OR REPLACE PROCEDURE SUMNUMBERS(NUM1 NUMBER DEFAULT 0, NUM2 NUMBER DEFAULT 0, NUM3 NUMBER DEFAULT 0, NUM4 NUMBER DEFAULT 0, NUM5 NUMBER DEFAULT 0)
IS
    SUMOFNUMBERS NUMBER;
BEGIN
    SUMOFNUMBERS := (NUM1 + NUM2 + NUM3 + NUM4 + NUM5);
    DBMS_OUTPUT.PUT_LINE('SUM OF NUMBERS: ' || SUMOFNUMBERS);
END;
/

-- EJERCICIO 9:
    -- ESCRIBE UNA FUNCIÓN QUE DEVUELVA SOLAMENTE CARACTERES ALFABÉTICOS
    -- SUSTITUYENDO CUALQUIER OTRO CARÁCTER POR BLANCOS
    -- A PARTIR DE UNA CADENA QUE SE PASARÁ EN LA LLAMADA
CREATE OR REPLACE FUNCTION REPLACINGCHARS(TEXTTOMODIFY VARCHAR) RETURN VARCHAR
IS
    MODIFIEDTEXT VARCHAR2(60);
BEGIN
    FOR I IN 1..LENGTH(TEXTTOMODIFY)
    LOOP
        IF REGEXP_LIKE(SUBSTR(TEXTTOMODIFY, I, 1), '[[:alpha:]]') THEN
            MODIFIEDTEXT := MODIFIEDTEXT || SUBSTR(TEXTTOMODIFY, I, 1);
        ELSE
            MODIFIEDTEXT := MODIFIEDTEXT || ' ';
        END IF;
    END LOOP;
RETURN MODIFIEDTEXT;
END;
/

-- EJERCICIO 10: CODIFICA UN PROCEDIMIENTO QUE PERMITA BORRAR UN EMPLEADO CUYO NUMERO SE PASARA EN LA LLAMADA

-- CREATE TABLES FOR EJERCICIO 10

CREATE TABLE EMP (
    ID NUMBER PRIMARY KEY,
    NAME VARCHAR2(100),
    SALARY NUMBER,
    DEPARTMENT VARCHAR2(50)
);

INSERT INTO EMP (ID, NAME, SALARY, DEPARTMENT)
VALUES (1, 'John Doe', 50000, 'IT');

INSERT INTO EMP (ID, NAME, SALARY, DEPARTMENT)
VALUES (2, 'Jane Smith', 60000, 'HR');


CREATE OR REPLACE PROCEDURE DROPEMP(IDEMP NUMBER)
IS
BEGIN
    DELETE FROM EMP WHERE EMP.ID = IDEMP;
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('A user with that ID does not exist');
END;
/

-- EJERCICIO 11:
    -- ESCRIBE UN PROCEDIMIENTO QUE MODIFIQUE LA LOCALIDAD DE UN DEPARTAMENTO
    -- EL PROCEDIMIENTO RECIBIRA COMO PARAMETROS EL NUMERO DEL DEPARTAMENTO, Y LA NUEVA LOCALIDAD
CREATE OR REPLACE PROCEDURE UPDATEDEPTLOCATION (DEPID NUMBER, NEWLOCATIONID NUMBER)
IS
BEGIN
    UPDATE DEPARTMENTS DEP
    SET DEP.LOCATION_ID = NEWLOCATIONID
    WHERE DEP.DEPARTMENT_ID = DEPID AND EXISTS (SELECT NULL FROM LOCATIONS LOC WHERE LOC.LOCATION_ID = NEWLOCATIONID);
EXCEPTION
    WHEN NO_DATA_FOUND THEN
        DBMS_OUTPUT.PUT_LINE('No department was found with this ID or the Location ID is not in the database');
END;
/

-- CREATE TABLES FOR EJERCICIO 11
CREATE TABLE LOCATIONS (
    LOCATION_ID NUMBER PRIMARY KEY,
    STREET_ADDRESS VARCHAR2(50),
    POSTAL_CODE VARCHAR2(20),
    CITY VARCHAR2(50),
    STATE_PROVINCE VARCHAR2(50),
    COUNTRY_ID CHAR(2)
);

CREATE TABLE DEPARTMENTS (
    DEPARTMENT_ID NUMBER PRIMARY KEY,
    DEPARTMENT_NAME VARCHAR2(50),
    MANAGER_ID NUMBER,
    LOCATION_ID NUMBER REFERENCES LOCATIONS(LOCATION_ID)
);

INSERT INTO LOCATIONS VALUES (1, '123 Main St', '12345', 'Anytown', 'AnyState', 'US');
INSERT INTO LOCATIONS VALUES (2, '456 Oak St', '56789', 'Othercity', 'OtherState', 'CA');

INSERT INTO DEPARTMENTS VALUES (101, 'HR', 201, 1);
INSERT INTO DEPARTMENTS VALUES (102, 'IT', 202, 2);

-- EJERCICIO 12: VISUALIZA TODOS LOS PROCEDIMIENTOS Y FUNCIONES DEL USUARIO ALMACENADOS EN LA BASE DE DATOS Y SU SITUACIÓN (VALID O INVALID)

CREATE OR REPLACE PROCEDURE VIEWMYINFO
IS
    MYUSERNAME VARCHAR2(100);
    OBJECT_NAME VARCHAR2(200);
    OBJECT_TYPE VARCHAR2(200);
    STATUS VARCHAR2(200);
    SQLQUERY VARCHAR2(200);
    CURSOR C_USERINFO IS SELECT OBJECT_NAME, OBJECT_TYPE, STATUS FROM ALL_OBJECTS WHERE OWNER = MYUSERNAME AND OBJECT_TYPE IN ('PROCEDURE', 'FUNCTION');
BEGIN
    --SELECT sys_context('userenv', 'session_user') INTO MYUSERNAME FROM dual;
    SELECT USER INTO MYUSERNAME FROM DUAL;
    OPEN C_USERINFO;
        FOR I IN (SELECT OBJECT_NAME, OBJECT_TYPE, STATUS FROM ALL_OBJECTS WHERE OWNER = MYUSERNAME AND OBJECT_TYPE IN ('PROCEDURE', 'FUNCTION')) LOOP
            FETCH C_USERINFO INTO OBJECT_NAME, OBJECT_TYPE, STATUS;
            DBMS_OUTPUT.PUT_LINE(OBJECT_NAME || ' IS ' || STATUS);
        END LOOP;
    CLOSE C_USERINFO;
END;
/